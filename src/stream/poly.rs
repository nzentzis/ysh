use std::io;
use std::os::unix::prelude::*;
use std::boxed::Box;
use std::sync::Arc;

use span::*;
use data::*;
use numeric::*;
use evaluate::*;
use super::{CharStream, StreamError};

#[derive(Clone, Copy, Debug)]
/// Options structure to use when generating a new polymorphic stream structure.
pub struct StreamOptions {
    /// specific character to use as a delimiter
    delimiter: Option<char>,
    
    /// split lines
    lines: bool,
    
    /// split fields
    fields: bool,
}

impl StreamOptions {
    /// Generate a new options structure
    pub fn new() -> Self {
        StreamOptions {
            delimiter: None,
            lines: true,
            fields: true
        }
    }

    /// Generate a new options structure representing "basic" mode; no parsing
    /// at all.
    pub fn basic() -> Self {
        StreamOptions {
            delimiter: None,
            lines: false,
            fields: false
        }
    }

    /// Set whether to split lines when parsing the stream
    pub fn lines(&mut self, enable: bool) -> &mut Self {
        self.lines = enable;
        self
    }

    /// Set the delimiter to use
    pub fn delimiter(&mut self, delim: char) -> &mut Self {
        self.delimiter = Some(delim);
        self
    }
}

#[derive(Clone)]
/// An underlying polystream object accessible via the public PolyStream
/// interface.
/// 
/// This is wrapped in an Arc so the iterated objects can just reference the
/// content of the stream instead of making copies.
struct InnerStream {
    opts: StreamOptions,
    stream: LazyReadStream,

    /// Stored field headers, if available
    headers: Option<Arc<Vec<String>>>,

    /// Current line number
    line: usize,

    /// The current frontmost span
    /// 
    /// If `None`, nothing has been read yet
    front: Option<Span>
}

impl InnerStream {
    /// Get the next line from this stream
    /// 
    /// Returns `None` when no further lines are available
    fn next_line(&mut self) -> io::Result<Option<PolyLine>> {
        let front = {
            if self.front.is_none() {
                self.front = Some(self.stream.read(100000)?);
            }
            self.front.as_ref().unwrap().to_owned()
        };

        let avail = front.clone();
        let avail_len = front.real_len();
        for (i,b) in avail.bytes().enumerate() {
            if b == b'\n' {
                // split here
                let new_span = avail.subspan(..i);

                // TODO: check that idx+1 is valid?
                if i+1 < avail_len {
                    self.front = Some(front.subspan(i+1..));
                } else {
                    self.front = Some(self.stream.read(512)?);
                }
                
                self.line += 1;
                let line = PolyLine::new_from(new_span, &self, self.opts.clone());

                // infer headers if possible
                if self.line == 1 {
                    self.try_infer_headers(&line);
                }

                return Ok(Some(line));
            }
        }

        if front.is_frozen() {
            return Ok(None);
        }

        // get more data and recurse
        self.stream.extend(self.front.as_mut().unwrap(), 512)?;
        self.next_line()
    }

    /// Try to infer the column headers
    ///
    /// Column header inference works by checking each field, then performing
    /// the following steps in order:
    ///
    /// 1. Remove any leading or trailing whitespace
    /// 2. If the first and last characters are both the same and not alphabetic,
    ///    remove leading and trailing instances of that character
    ///
    /// After this, if more than 80% of the characters in the resulting fields
    /// are alphabetic and none begin with a digit, then the inference succeeds.
    /// Field names (compatible with the atom syntax) are generated by running
    /// the modified text through the following steps:
    ///
    /// 1. Remove any parentheses or square brackets
    /// 2. Replace any underscores with dashes
    /// 3. Replace any spaces with dashes
    /// 4. Convert all values to lower case if doing so would not produce
    ///    duplicates
    ///
    /// If the results include duplicates, fail the inference
    fn try_infer_headers(&mut self, line: &PolyLine) {
        // figure out how many fields there are, and accumulate their contents
        let mut fields = line.fields.iter()
                        .map(|x| x.data.copy(..))
                        .map(|x| String::from_utf8_lossy(&x).into_owned())
                        .collect::<Vec<_>>();

        for f in fields.iter_mut() {
            let r = {
            let m = f.trim();
            if m.is_empty() { continue; }

            let (start, end) = (m.chars().next().unwrap(),
                                m.chars().last().unwrap());

            // strip start/end chars
            if start == end && !start.is_alphabetic() {
                m.trim_matches(start).to_owned()
            } else {
                m.to_owned()
            }
            };
            *f = r;
        }

        let mut num_alpha = 0;
        let mut num_total = 0;
        for f in fields.iter() {
            for c in f.chars() {
                if c.is_alphabetic() { num_alpha += 1; }
                num_total += 1;
            }
        }

        if num_alpha < (num_total / 8) { return; }

        // If we get here, we passed the field inference criteria. Go replace
        // the field bodies.
        
        // remove parens, replace underscores and spaces
        for f in fields.iter_mut() {
            f.retain(|c| c != '(' && c != ')' && c != '[' && c != ']');

            *f = f.replace('_', "-").replace(' ', "-");
        }

        // build a copy with values converted
        let modified = fields.iter()
                      .map(|x| x.to_lowercase())
                      .collect::<Vec<_>>();

        let mut modified_alt = modified.clone();
        modified_alt.sort();
        modified_alt.dedup();

        let final_fields = if modified_alt.len() != modified.len() { fields }
                           else { modified };

        // double-check to make sure there's no duplicates
        let mut modified_alt = final_fields.clone();
        modified_alt.sort();
        modified_alt.dedup();
        if modified_alt.len() != final_fields.len() { return; } // fail on dupes
        else {
            self.headers = Some(Arc::new(final_fields));
        }
    }
}

pub struct PolyStream {
    inner: InnerStream
}

impl PolyStream {
    /// Create a stream to parse and process the given input stream
    /// 
    /// This requires that the PolyStream be the sole owner of the given file
    /// descriptor.
    /// 
    /// It's not suitable for pulling data from stdin.
    pub fn from_fd(fd: RawFd, opts: StreamOptions) -> io::Result<Self> {
        let strm = LazyReadStream::new(fd)?;
        Ok(PolyStream {
            inner: InnerStream {
                opts, front: None, headers: None, line: 0,
                stream: strm,
            }
        })
    }

    /// Open a stream from stdin
    pub fn from_stdin(opts: StreamOptions) -> io::Result<Self> {
        let strm = LazyReadStream::stdin()?;
        Ok(PolyStream {
            inner: InnerStream {
                opts, front: None, headers: None, line: 0,
                stream: strm
            }
        })
    }
}

impl CharStream for PolyStream {
    fn peek(&self) -> Result<char, StreamError> {
        unimplemented!()
    }

    fn next(&self) -> Result<char, StreamError> {
        unimplemented!()
    }

    fn push(&self, c: char) {
        unimplemented!()
    }
}

struct LineIterator {
    stream: InnerStream
}

impl Iterator for LineIterator {
    type Item = EvalResult;

    fn next(&mut self) -> Option<EvalResult> {
        match self.stream.next_line() {
            Ok(r) => r.map(Value::new).map(Ok),
            Err(e) => Some(Err(EvalError::IO(e)))
        }
    }
}

impl ValueLike for PolyStream {
    fn into_seq(&self) -> Eval<Vec<Value>> {
        Eval::from(self.into_iter().collect::<Result<_, _>>())
    }

    fn into_iter(&self) -> ValueIteratorBox {
        Box::new(LineIterator { stream: self.inner.clone() })
    }

    fn evaluate(&self, _env: &::environment::Environment) -> Eval<Value> {
        Eval::from(Ok(Value::new(PolyStream { inner: self.inner.clone() })))
    }

    fn into_str(&self) -> Eval<String> {
        Eval::from(Ok(String::from("<polystream>")))
    }

    fn into_args(&self) -> Eval<Vec<String>> {
        unimplemented!()
    }

    fn first(&self) -> Eval<Option<Value>> {
        unimplemented!()
    }
}

#[derive(Clone)]
/// A line from a polymorphic stream. Handles field conversion and acts as a
/// list-like object.
pub struct PolyLine {
    opts: StreamOptions,
    data: Span,
    fields: Vec<PolyField>,
    labels: Option<Arc<Vec<String>>>,
    number: usize
}

impl PolyLine {
    fn new_from(span: Span, inner: &InnerStream, opts: StreamOptions) -> PolyLine {
        #[derive(Debug, PartialEq, Eq, Copy, Clone)]
        enum FieldSplitState {
            Start, // start state (space-separated only)
            LeftBlanks,
            ReadData,
            RightBlanks,
            CheckSep, // separator check state (space-separated only)
        }

        let mut field_regions = Vec::new();

        let sep = opts.delimiter.unwrap_or(' ');
        if sep == ' ' {
            let mut state = FieldSplitState::Start;
            let mut start_idx = 0;
            let mut lspace = 0;
            let mut rspace = 0;
            let mut length = 0;

            let mut bias = false; // whether to bias to left alignment

            // split on spaces
            let mut last_idx = 0;
            for (i,c) in span.chars().enumerate() {
                last_idx = i;
                match state {
                    FieldSplitState::Start => {
                        if c == ' ' {
                            // if the first char is a space, bias left
                            bias = true;
                            lspace += 1;
                            state = FieldSplitState::LeftBlanks;
                        } else {
                            state = FieldSplitState::ReadData;
                            length += 1;
                        }
                    },
                    FieldSplitState::LeftBlanks => {
                        if c == ' ' {
                            lspace += 1;
                        } else {
                            length += 1;
                            state = FieldSplitState::ReadData;
                        }
                    },
                    FieldSplitState::ReadData => {
                        if c == ' ' {
                            state = FieldSplitState::CheckSep;
                        } else { // grab more body
                            length += 1;
                        }
                    },
                    FieldSplitState::CheckSep => {
                        if c != ' ' {
                            // end field
                            field_regions.push((start_idx,
                                                lspace,
                                                length,
                                                rspace,
                                                i-1));
                            start_idx = i;
                            lspace = 0; rspace = 0; length = 1;
                            state = FieldSplitState::ReadData;
                        } else {
                            // if biased left, break immediately, but if we're
                            // biasing toward right alignment then we have to
                            // consume spaces
                            if bias {
                                field_regions.push((start_idx,
                                                    lspace,
                                                    length,
                                                    rspace,
                                                    i-1));
                                start_idx = i+1;
                                lspace = 0; rspace = 0; length = 0;
                                state = FieldSplitState::LeftBlanks;
                            } else {
                                state = FieldSplitState::RightBlanks;
                                rspace += 1;
                                // rspace should be 1 less than normal since it
                                // needs to account for the next delimiter
                                // but the extra space is already dropped when
                                // transitioning to this state.
                            }
                        }
                    },
                    FieldSplitState::RightBlanks => {
                        if c == ' ' {
                            rspace += 1;
                        } else {
                            // end field
                            field_regions.push((start_idx,
                                                lspace,
                                                length,
                                                rspace,
                                                i-1));
                            start_idx = i;
                            lspace = 0; length = 0; rspace = 0;
                            state = FieldSplitState::ReadData;
                        }
                    },
                }
            }
            let end_idx = match state {
                FieldSplitState::CheckSep => last_idx,
                _ => last_idx+1,
            };
            field_regions.push((start_idx, lspace, length, rspace, end_idx));
        } else {
            let mut state = FieldSplitState::LeftBlanks;
            let mut start_idx = 0;
            let mut end_idx;
            let mut lspace = 0;
            let mut rspace = 0;
            let mut length = 0;

            // split on delimiter
            let mut last_idx = 0;
            for (i,c) in span.chars().enumerate() {
                last_idx = i;
                match state {
                    FieldSplitState::LeftBlanks => {
                        if c == sep {
                            state = FieldSplitState::LeftBlanks;
                            end_idx = i;
                        } else if c != ' ' {
                            start_idx = i;
                            length = 1;
                            state = FieldSplitState::ReadData;
                            continue;
                        } else {
                            lspace += 1;
                            continue;
                        }
                    },
                    FieldSplitState::ReadData => {
                        if c == sep {
                            state = FieldSplitState::LeftBlanks;
                            end_idx = i;
                        } else if c == ' ' {
                            state = FieldSplitState::RightBlanks;
                            rspace += 1;
                            continue;
                        } else {
                            length += 1;
                            continue;
                        }
                    },
                    FieldSplitState::RightBlanks => {
                        if c == sep {
                            state = FieldSplitState::LeftBlanks;
                            end_idx = i;
                        } else if c == ' ' {
                            rspace += 1;
                            continue;
                        } else {
                            // more body data - go back and adjust
                            length += rspace + 1;
                            rspace = 0;
                            state = FieldSplitState::ReadData;
                            continue;
                        }
                    },
                    _ => panic!("invalid FSM state for separator mode")
                }

                // end of field
                field_regions.push((start_idx, lspace, length, rspace, end_idx));

                // set up for next
                start_idx = i;
                length = 0;
                lspace = 0;
                rspace = 0;
            }

            field_regions.push((start_idx, lspace, length, rspace, last_idx+1));
        }

        let num_field_indices = inner.headers.as_ref()
                               .map(|x| x.len())
                               .unwrap_or(0);

        let fields: Vec<_> = field_regions.into_iter()
            .enumerate()
            .map(|(idx, (start,l,_len,r,end))| {
                let data =
                    if (end-r) > span.real_len() { span.subspan(start+l..) }
                    else { span.subspan(start+l..end-r) };
                PolyField {
                    data,
                    info: FieldInfo {
                        start: start,
                        length: end-start,
                        pad: ' ',
                        align: if l > 0 { Alignment::Left }
                               else { Alignment::Right },
                        field: if idx < num_field_indices {Some(idx)}
                               else {None}
                    }
                }
            })
            .collect();

        PolyLine {
            opts,
            data: span,
            fields,
            labels: inner.headers.clone(),
            number: inner.line
        }
    }
}

impl ValueLike for PolyLine {
    fn into_iter(&self) -> ValueIteratorBox {
        Box::new(self.fields.clone().into_iter()
                     .map(Value::new)
                     .map(Ok))
    }

    fn evaluate(&self, _env: &::environment::Environment) -> Eval<Value> {
        Eval::from(Ok(Value::new(self.clone())))
    }

    fn into_str(&self) -> Eval<String> {
        let x = self.data.copy(..);
        Eval::from(Ok(String::from_utf8_lossy(x.as_slice()).into_owned()))
    }

    fn first(&self) -> Eval<Option<Value>> {
        unimplemented!()
    }

    fn get_key(&self, key: &Value) -> Eval<Option<Value>> {
        // If the key's an atom, try matching fields. Otherwise, match indices.
        match key.into_num().wait() {
            Ok(Some(n)) => {
                let idx = n.round();

                if (idx < 0) || ((idx as usize) >= self.fields.len()) {
                    return Eval::from(Ok(None));
                } else {
                    let f = self.fields[idx as usize].clone();
                    return Eval::from(Ok(Some(Value::new(f))));
                }
            },
            Ok(None) => {},
            Err(e) => {return Eval::from(Err(e));}
        }

        // not a number, so check if it's an atom
        Eval::from(if let ValueData::Atom(ref s) = key.data {
            if let Some(r) = self.labels.as_ref() {
                // make sure the requested atom is in the key list
                let idx = r.iter()
                         .enumerate()
                         .filter(|(_,x)| *x == s.as_ref())
                         .next()
                         .map(|(i,_)| i);
                Ok(idx.and_then(|i| {
                    // get the element
                    if i >= self.fields.len() { None }
                    else { Some(Value::new(self.fields[i].clone())) }
                }))
            } else {
                Ok(None)
            }
        } else {
            // not a valid index
            Err(EvalError::TypeError(String::from(
                        "Cannot index stream line with non-key type")))
        })
    }
}

#[derive(Copy, Clone, PartialEq, Eq, Debug)]
enum Alignment {
    Left, // left align
    Right, // right align
}

#[derive(Copy, Clone, PartialEq, Eq, Debug)]
struct FieldInfo {
    align: Alignment,
    pad: char,
    start: usize, // field start column
    length: usize, // length in columns
    field: Option<usize> // the field index into the line's label vector, if any
}

#[derive(Clone)]
/// A field from a polymorphic stream. Handles conversion to/from other types
/// and acts as a (number/string)-like object
/// 
/// This object is *unfrozen*, meaning that it can be used as any type to which
/// it has a defined conversion. Once the conversion happens, the result will be
/// frozen and type-checked normally.
/// 
/// In other words, for two polyfields `x` and `y` the forms `(+ x y)` and
/// `(str/strip x)` will both succeed, but `(+ (chars x) y)` would fail since
/// the result of `(str/strip x)` would be a string rather than a polymorphic
/// object.
pub struct PolyField {
    data: Span,
    info: FieldInfo
}

impl ValueLike for PolyField {
    fn into_iter(&self) -> ValueIteratorBox {
        Box::new(Value::new(self.to_owned()).into_iter())
    }

    fn evaluate(&self, _env: &::environment::Environment) -> Eval<Value> {
        Eval::from(Ok(Value::new(self.to_owned())))
    }

    fn into_str(&self) -> Eval<String> {
        let x = self.data.copy(..);
        Eval::from(Ok(String::from_utf8_lossy(x.as_slice()).into_owned()))
    }

    fn into_num(&self) -> Eval<Option<Number>> {
        use reader::parse_number;

        // try parsing as a number
        let data = self.data.copy(..);
        let n = parse_number(data.as_slice());

        if let Ok(n) = n.result {
            Eval::from(Ok(Some(n)))
        } else {
            Eval::from(Ok(None))
        }
    }

    fn first(&self) -> Eval<Option<Value>> {
        Eval::from(Ok(Some(Value::new(self.to_owned()))))
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use std::io::Cursor;

    fn mk_stream(data: &'static [u8]) -> LazyReadStream {
        LazyReadStream::from_reader(Cursor::new(data)).unwrap()
    }

    // TODO: fix these
    /*
    #[test]
    fn line_simple() {
        let l_data = "1234 abcd 1.24 6-7i ";
        let mut strm = mk_stream(l_data.as_bytes());

        let mut s1 = strm.read(26).unwrap();
        while !s1.is_frozen() { strm.extend(&mut s1, 8).unwrap(); }

        let opts = StreamOptions::new();
        let l = PolyLine::new_from(s1, opts);

        assert_eq!(l.into_str().wait().unwrap(), l_data);
        assert_eq!(l.into_iter()
                    .map(|x| x.and_then(|v| v.into_str().wait()))
                    .collect::<EvalRes<Vec<_>>>().unwrap(),
                    vec!["1234", "abcd", "1.24", "6-7i"]);
    }

    #[test]
    fn line_left_padded() {
        let l_data = "    1234    abcd    1.24    6-7i ";
        let mut strm = mk_stream(l_data.as_bytes());

        let mut s1 = strm.read(26).unwrap();
        while !s1.is_frozen() { strm.extend(&mut s1, 8).unwrap(); }

        let opts = StreamOptions::new();
        let l = PolyLine::new_from(s1, opts);

        assert_eq!(l.into_str().wait().unwrap(), l_data);
        assert_eq!(l.into_iter()
                    .map(|x| x.and_then(|v| v.into_str().wait()))
                    .collect::<EvalRes<Vec<_>>>().unwrap(),
                    vec!["1234", "abcd", "1.24", "6-7i"]);
    }

    #[test]
    fn line_right_padded() {
        let l_data = "1234    abcd    1.24    6-7i";
        let mut strm = mk_stream(l_data.as_bytes());

        let mut s1 = strm.read(26).unwrap();
        while !s1.is_frozen() { strm.extend(&mut s1, 8).unwrap(); }

        let opts = StreamOptions::new();
        let l = PolyLine::new_from(s1, opts);

        assert_eq!(l.into_str().wait().unwrap(), l_data);
        assert_eq!(l.into_iter()
                    .map(|x| x.and_then(|v| v.into_str().wait()))
                    .collect::<EvalRes<Vec<_>>>().unwrap(),
                    vec!["1234", "abcd", "1.24", "6-7i"]);
    }

    #[test]
    fn separated_simple() {
        let l_data = "1234|abcd|1.24|6-7i";
        let mut strm = mk_stream(l_data.as_bytes());

        let mut s1 = strm.read(26).unwrap();
        while !s1.is_frozen() { strm.extend(&mut s1, 8).unwrap(); }

        let mut opts = StreamOptions::new();
        opts.delimiter('|');
        let l = PolyLine::new_from(s1, opts);

        assert_eq!(l.into_str().wait().unwrap(), l_data);
        assert_eq!(l.into_iter()
                    .map(|x| x.and_then(|v| v.into_str().wait()))
                    .collect::<EvalRes<Vec<_>>>()
                    .unwrap(),
                    vec!["1234", "abcd", "1.24", "6-7i"]);
    }
    */
}

